<!DOCTYPE html>
<html>
<head>
    <title>TDD and OOP workshop</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

        body {
            font-family: 'Droid Serif';
        }

        h1, h2, h3 {
            font-family: 'Yanone Kaffeesatz';
            font-weight: normal;
        }

        .inverse {
            color: white;
            text-shadow: 0 0 20px #333;
        }

        .inverse h1, .inverse h2 {
            color: #f3f3f3;
            line-height: 0.8em;
        }

        .footnote {
            position: absolute;
            bottom: 3em;
        }

        /* Two-column layout */
        .left-column {
            width: 45%;
            height: 92%;
            float: left;
            padding-right: 1em;
        }

        .left-column h2:last-of-type, .left-column h3:last-child {
            color: #000;
        }

        .right-column {
            width: 45%;
            float: right;
            padding-left: 1em;
        }

        .remark-code, .remark-inline-code {
            font-family: 'Ubuntu Mono';
        }
    </style>
</head>
<body>
<textarea id="source">

name: inverse
layout: true
class: inverse

---
layout: false
background-image: url(img/title-screen-background.png)
background-size: contain
background-repeat: no-repeat
background-position: bottom
class: center top

# TDD with OOP workshop



---

##\#whoami


In IT since 2006, in Java since 2014

Practice TDD since then

In Vattenfall since 2016

Currently developer and solution architect in eMobility

From time to time speaker at community events and conferences
---

##\#whoareyou

Introduction round, let's share our....

Name

Occupation

Experience

TDD & OOP familiarity

Expectations

---
##Organization/contract

We are not in school

Lunch break

Coffee breaks

Let's treat breaks' endings strictly

Learning/performing mode
---
##Agenda

1. TDD
    - basics
    - integration and unit tests
    - mocks, stubs, fakes
    - tests as design tool
    - exercises

2. OOP
    - basics
    - SOLID
    - Cohesion and coupling
    - exercises

3. Bigger coding *kata*

---
##TDD

What is it about?

Have you tried it?

Are you using it?

Is it hard?

Is it beneficial?

---
##Feedback loops

How fast do you want to know that software is working?

How fast is *fast*?

Automatic tests for the rescue, but they must be *fast*

Long feedback loops kills focus

Core of eXtreme Programming and Agile Software Development

---
##Feedback loops

<img src="../images/feedback_cyclesncr.png" width="640"/>
---
##Testing

What good test should do?

What features good test has?

What would you expect from good tests?
---
##Test Driven Development

<img src="../images/tdd_flow.gif">
---
##RED Phase

Write a test for new behaviour that is failing

It might even not compile, and that's OK!

---
##GREEN Phase

Make test compile if it is required

Make test pass

---
##REFACTOR Phase

Remove duplications

Change code structure

Introduce patterns (but no new behaviour!)

Both test and production code might be refactor, but not in parallel

THE MOST UNDERRATED PART OF TDD
---

##Test Driven Development

You are not allowed to write any production code unless it is to make a failing unit test pass.

You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.

You are not allowed to write any more production code than is sufficient to pass the one failing unit test.
---
##Why to start from test?

Specify what you want first, than how

Focus on behaviour

Enforces small steps

There is no excuse like "we will test later"

---
##Non-Test Driven Development

Are you sure, that

- your solution works?

- you have not broken anything while going step-by-step?

- all cases are probably tested?

If so, how can you prove it?
---
##Non-Test Driven Development

Adding tests afterwards?

Building regression suite?

Is actually a legacy code working strategy.


---
##Test structure

_Given_

Test setup - initial conditions

_When_

Behaviour under test

_Then_

Verification of behaviour, assertion

This approach came from *BDD* - Behaviour Driven Development
---
##Test Driven Development

Let's code something!

---

##What have we learned so far?
---

##What have we learned so far?
TDD loop

Start from test

Start from assertion

Step by step

---
##Qualities of good tests

Minimize programmer waiting.

Run reliably.

Predict deployability.

Respond to behavior changes.

Not respond to structure changes.

Be cheap to write.

Be cheap to read.

Be cheap to change.

---
##FIRST

Fast

Isolated/independent

Repeatable

Self-validating

Thorough/Timely

---
##TDD benefits

Do you see any at the moment?

---
##TDD benefits

Enforces slice, by slice, step by step approach

Safety and comfort

Enables free refactoring

Drives development

Documentation

---

##Tools

Spock Framework

JUnit, plenty of assertions tools e.g. AssertJ

---
##Let's have a break

---
##Let's implement something less academic

How about VOD PPV service?

---
##Step 1

We seem to be missing something!

---
##Types of tests

Unit

Integration

---
##Unit tests

What is a unit?

A class?

A method?

Testing private methods?

A cluster of objects?

A behaviour?

---
##Integration tests

I/O integration

What I/O is?
---
##Test pyramid

<img src="../images/test-pyramid.png" width="640">
---
##Unit vs integration test

Which test type should we use when?
---
##Unit vs integration test

Unit

- business logic (business related if's)

- as much as possible

Integration

- processes

- happy/critical paths

---
##Testing approaches

Black box

White box
---
##Blackbox testing

Focused on behaviour

Couples with behaviour (test changes, when behaviour changes)

Ignores implementation details
---
##Whitebox testing

Assumes knowledge of implementation details

Couples with implementation (test changes, when implementation changes)

---
##Testing approaches pros/cons

Black box

White box

What do you think?

---
##Fake

<img src="../images/fake.png" width="640"/>

---
##Fake

Working implementations

Not suitable for production

Map, HashMap, Collection etc. used as in-memory DB
---
##Step 2

Also some insight needed here

---
##Mocks

<img src="../images/mock.png" width="640"/>
---
##Mocks

Specification of the calls they are expected to receive

Can throw an exception if they receive a call they don't expect

Checked during verification to ensure they got all the calls they were expecting

---

##Stub

<img src="../images/stub.png" width="640"/>
---

##Stub

Provide predefined answers to calls made during the test

Input is not important


---
## Mock, Stubs, Fakes

Use at module boundaries

Use fake for custom DB implementation to speed up testing

---
##Tools

Custom implementation :)

Spock Framework

Mockito for JUnit
---
##Step 6

Bugfixing and TDD

Add test reproducing the bug

Fix it

---

##TDD and existing code

Refactoring

Cover with tests

Refactor safely and without stress


---
##TDD as design tool

Is TDD design tool itself?

Navigates through designing

Enforces (re)design step

Doesn't tell *how* to design
---
##What have we learned here?

Unit and integration tests

Fake implementation, stubs, mocks

---
##Let's have a break

---

##Object Oriented Programming (OOP)

Object Oriented system - web of communicating object

OOP is about behaviour, not data

---

##Object Oriented Programming (OOP)

Paradigm as in school:

Encapsulation

Polymorphism

Inheritance

---
##OOP - encapsulation/information hiding

Realised with _access modifiers_

Hidden implementation details

Scalable at multiple levels

Is class with getters/setters encapsulated?

---
##OOP - encapsulation/information hiding

Let's see code sample

---
##OOP - tell don't ask (Demeter law)

You may call methods of objects that are:

1. Passed as arguments

2. Created locally

3. Instance variables

4. Globals

---
##OOP - tell don't ask (Demeter law)

Let's see code sample

---
##OOP - encapsulation at scale

Modules and microservices

But what about module internals?

---
##OOP -encapsulation at scale

Let's see code sample

---

##OOP - inheritance

Currently considered as bad practice

Base class is tightly coupled with its descendant

Prefer composition over inheritance

TODO: Risks: broken encapsulation, high coupling, code sample

---
##OOP - polymorphism

Interface and implementation(naming)

Strategy/state design pattern

Naming conventions?

---
##OOP - polymorphism
Let's see a sample

---
##OOP in practice

What does Object Oriented language mean?

Is Java an OO language?

If no, what should be changed?

Is '''class''' keyword enough to be OO?

---
##OOP in practice

So, let's see what class can define.

---
##OOP in practice

A "object" in Java, can be:

Value object

Real object

Data structure a.k.a DTO (how about DB objects, like JPA Entities?)

Procedure

Function

---
##OOP in practice

How could we implement a Euro object?



---
##OOP in practice - heuristics

SOLID

Cohesion - coupling


---
##SOLID

SRP

OCP

LSP

ISP

DIP


TODO: examples
---

##SRP

Single Responsibility Principle

How do you understand it?

---

##SRP

Single Responsibility Principle

"Do one thing"

"One reason to change"

Sounds quite academic

Do even authors understand it?

---
##OCP

Open Closed Principle

How do you understand it?
---
##OCP

Open Closed Principle

"Open for extensions, closed for modification"

What design patterns styles support it?

DI

IOC

Interfaces

Events

Higher order functions

---
##LSP

Substitution of interfaces' implementation must be possible

How do you understand it?
---
##LSP

Substitution of interfaces' implementation must be possible

Focus on behaviour

How code must be tested to ensure it?

---
##ISP

Interface segregation principle

How do you understand it?
---
##ISP

Interface segregation principle

API width

---
##DIP

Client should depend on abstraction not implementation

How do you understand it?

---
##DIP

Client should depend on abstraction not implementation

Should everything have interface?
---
##Cohesion and coupling

WTF are they?

---
##Cohesion

_Degree to which the elements inside a module belong together_

When class' behaviours implemented in methods, have much in common cohesion is increased

Ideally class has one method which operates on all class' fields
---
##Increasing cohesion

Extract/split classes

Separate logic from I/O on class/package level

Build packages on functionalities not layers
---
##Benefits of high cohesion

Reduced complexity

High maintainability, easier refactoring

Good readability
---

##Coupling

Changing in one place needs change in an other place as well
---
##Decoupling

Process of reducing coupling:

Same class

Inheritance

Composition/Dependency injection

Events

---
##High cohesion - loose coupling

Probably most important design heuristic(s) in IT development

OOP

DDD

Modules

Microservices


---

##TDD and OOP - testing and design

A *Unit* can be quite flexible

Java has default access - so called package private

How about this: public facade serving as an API
---
##TDD and design

Does TDD itself lead to good design?

Helps a lot, but...

At least some overview design might be useful

Bad testability usually is a marker of bad design

---
##Vending machine kata

---
<img src="../images/thatsall.jpg" width="640"/>

    </textarea>
<script src="https://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript"></script>
<script type="text/javascript">
    var slideshow = remark.create({
        countIncrementalSlides: false
    });
</script>
</body>
</html>
